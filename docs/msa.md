현재 시스템은 모놀리틱 구조를 가진다. <br>
유저, 결제, 예약, 대기열 등 모든 도메인이 하나의 데이터베이스에 의존한다 <br>
이 방식의 장점은 모든 기능이 단일 트랜잭션 내에서 실행되고, 데이터베이스의 일관성 유지가 간단한 것이다. <br>
하지만, 서비스가 커지면 어느 시점에 MSA 전환을 고려해야 한다 <br>

## MSA 전환 시점
사업을 시작하면 모든 회사는 생존을 걱정한다. <br>
국가에서 지원하는 투자금을 통해 사업을 연명하다 지속적인 적자를 감당하지 못해 파산하는 경우가 있고 <br>
유망한 스타트업으로 주목받다 그저그런 중소기업으로 끝나는 경우도 다반사다. <br>
그러나, 어떤 회사는 초기 스타트업을 벗어나 비즈니스의 규모가 어느정도 궤도에 오르게 된다 <br>
그러한 시점이 오면 모놀리틱 방식의 단점이 점점 생긴다
- 하나의 repository 에 매우 많은 코드가 있어 코드 파악과 유지보수가 어려워진다
- 확장성이 떨어진다
- 테스트, 배포의 속도가 점점 느려지고 정기 배포 절처가 생긴다

개인적인 생각이지만 위 단점들 중 상위 2개는 리팩토링을 통해 어느정도 감당할 수 있다고 생각한다. <br>
코드의 일관성을 맞추고 도메인 별로 기능을 잘 분리해 놓는다면 모놀리틱 임에도 다른 팀에 영향을 미치지 않고 <br>
개발이 가능할 수도 있을 것 같다

하지만 정기 배포의 경우, 도메인 별 팀이 10팀인데 9팀은 수정한게 없는데 1팀만 수정을 했다. <br>
이를 위해, 모든 팀이 에러 발생을 위해 배포날 기다리고 배포가 되는 동안 다른 서비스들도 사용이 불가하다 <br>
최악은 작은 기능의 에러가 시스템 전체의 장애가 될 가능성도 존재한다는 것이다. <br>
이러한 문제를 막기 위해 우리는 도메인별로 개발하는 MSA 의 도입을 고려하게 된다

## MSA 장점 / 단점
- 장점
  - 빠른 구현과 배포
  - 도메인별로 독립적인 서비스 운영 가능
- 단점
  - 트랜잭션이 분산되어 있어 데이터 정합성을 유지하기 어려움
  - 네트워크 기반의 API 호출로 프로세스간 통신에 비해 느림
  - 장애추적 및 모니터링이 어려움

## 서비스 설계
우리의 서비스는 아래와 같이 5가지의 기능으로 구분된다
- 유저 토큰 발급
- 예약 가능 날짜 / 좌석
- 잔액 충전 / 조회
- 좌석 예약 요청
- 결제

### 유저 토큰 발급
다른 서비스와의 상호작용이 없다. Queue 혹은 Token 이라는 이름의 도메인으로 구분할 수 있다

### 예약 가능 날짜 / 좌석
좌석은 콘서트가 없으면 존재할 수 없다. 즉, 좌석이 콘서트의 하위 도메인 느낌이므로 Concert 와 Seat 를 묶어 Concert 로 관리할 수 있다

### 잔액 충전 / 조회
유저에 대한 정보이다. 결재 시에 잔액을 조회하여 결제 도메인과 연관될 수 있는데 결제에서 잔액의 조회는 <br>
주요 기능이라 볼 수 없다. 따라서, Member 로 분리할 수 있다

### 좌석 예약 요청 / 결제
예약과 결제가 가장 결정하기 힘든 부분이다 <br>
보통의 비지니스는 예약을 하고 보통 결제를 하는 프로세스가 많다 <br>
따라서, 비지니스 적으로 매우 강결합을 가지는데 예약의 개발건이 정말 많고 결제도 정말 많다면 <br>
두 도메인을 별개의 도메인으로 처리해서 따로 개발하는게 나을 수 있다 <br>
하지만, 예약과 결제는 매우 밀접한 관계를 맺고 있고 하나의 팀에서 관리를 하는 것이 <br>
유지보수와 장애추적 관점에서 더 효율이 나을 것으로 생각되어 Pay 라는 도메인으로 분리할 수 있다

그 외에 외부 API 호출 같은 부가 기능들이 존재하는데 이러한 기능들은 비지니스의 영향 여부나 <br>
코드의 규모를 기반으로 분리할 지 결정할 수 있다. <br>
하지만, 크게 영향이 없다면 해당 기능이 필요한 도메인 내부에 구현한다

## 트랜잭션 분리
현재 구현된 모든 기능을 보면 도메인 별로 다른 서비스를 의존하는 것은 Pay 밖에 존재하지 않는다 <br>
다른 도메인은 단순히 repository 를 의존하고 있어 트랜잭션을 분리할 필요는 없다. <br>
```java
@Transactional
@Override
public Pay pay(PayRequest request) {
    // 1. 예약 아이디 검증
    Reservation reservation = reservationService.findById(request.reservationId());
    reservation.matchMember(reservation.getMemberId(), request.memberId());
    reservation.isAvailable();

    Pay pay = Pay.createPay(reservation);
    
    // 2. 잔액 차감
    memberService.minusBalance(request.memberId(), reservation.getPrice());
    // 3. 좌석 정보 수정
    seatService.updateReservedAt(request.seatId(), LocalDateTime.of(9999, 12, 31, 23, 59, 59));
    // 4. 토큰 만료
    queueService.expireActiveToken(request.memberId());
    // 5. 슬랙으로 결제 정보 전송
    eventPublisher.publishEvent(PaySendEvent.from(pay));

    return payRepository.pay(pay);
}
```
결재 기능은 다음과 같다
1. 예약 아이디 검증 (Reservation)
2. 잔액 차감 (Member)
3. 좌석 정보 수정 (Seat)
4. 토큰 만료 (Queue)
5. 슬랙으로 결제 정보 전송

`1. 예약 아이디 검증`의 경우 예약과 결제를 하나의 도메인 으로 묶었기에 고려 대상이 아니다 <br>
그러면 실제로 트랜잭션이 적용되야 하는 부분은 `2. 잔액 차감` 과 `3. 좌석 정보 수정`이다 <br>
위 두 과정은 동기적으로 실행이 되어야 하기에 @EventListener 를 사용해 호출하고 하나의 트랜잭션으로 묶어야한다. <br>
좌석 정보 수정에서 에러가 나면 잔액 차감이 롤백되어야 하므로 보상 트랙재션을 통해 이를 구현한다. <br>
`4. 토큰 만료` 와 `5. 슬랙으로 결제 정보 전송` 의 경우 pay 메서드에서 하나의 트랜잭션으로 묶일 필요가 없다. <br>
트랜잭션이 끝나고 비동기로 동작해도 무방한 기능이기에 @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT) <br>
을 통해 결제가 정상적으로 완료되면 실행시켜 데이터 정합성을 보장한다.

## 해결 방안
분산환경으로 바뀌며 서비스 간의 데이터 일관성과 트랜잭션 관리를 유지하는 것이 중요하다. <br>
이를 유지하기 위해 몇가지 방법이 존재한다
### SAGA 패턴
SAGA 패턴은 분산 트랜잭션 관리의 한계를 해결하기 위한 방법으로, 각 서비스가 독립적으로 트랜잭션을 처리하면서, <br>
실패 시 이전의 상태로 롤백하는 보상 트랜잭션을 정의하는 방식이다

### 2PC
여러 서비스가 분산된 트랜잭션을 관리해야 할 때, 트랜잭션 코디네이터가 각 서비스의 트랜잭션 상태를 조정하여 <br>
커밋 또는 롤백을 결정한다

### 이벤트 드리븐 아키텍처 + 카프카
서비스 간의 트랜잭션을 비동기 이벤트로 처리한다. 카프카와 같은 메세지큐를 이용해 이벤트를 비동기적으로 처리하고 <br> 
데이터 일관성을 유지한다

### 결과
이번 과제에선 이벤트 드리븐 아키텍처 + 카프카 를 이용해 구현한다 <br>
이벤트를 이용해 동기적으로 처리가 필요한 부분은 동기적으로 처리하고 비동기적으로 처리가 필요한 부분은 <br>
카프카를 이용해 요청을 모아놓고 비동기적으로 구현해 시스템의 부하를 줄임과 동시에 코드레벨에서 도메인 간의 복잡도를 줄일 수 있다.

